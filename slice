#!/usr/bin/env python3
from datetime import date, datetime, timedelta
import difflib
import os
import re
import string
import subprocess
import sys
import tempfile

def log(str=""):
  sys.stderr.write(str)
  sys.stderr.write("\n")


editor_path = os.environ["EDITOR"]

todo_file_path = os.environ["TODO_FILE"]
date_on_add = os.environ["TODOTXT_DATE_ON_ADD"] == "1"
default_create_date = date.today() if date_on_add else None
preserve_line_numbers = os.environ["TODOTXT_PRESERVE_LINE_NUMBERS"] == "1"
disable_filter = os.environ["TODOTXT_DISABLE_FILTER"] == "1"


class ColorDiff:
  __CYAN = "\033[36m"
  __RED = "\033[31m"
  __GREEN = "\033[32m"
  __DEFAULT = "\033[0m"

  # prints colored diff lines to the terminal
  @classmethod
  def diff(cls, header, a, b):
    a_out = [cls.__CYAN, header]
    b_out = [cls.__CYAN, header]

    sm = difflib.SequenceMatcher(a = a, b = b, autojunk = False)
    for tag, i1, i2, j1, j2 in sm.get_opcodes():
      a_out.append(cls.__RED if tag == "replace" or tag == "delete" else cls.__DEFAULT)
      a_out.append(a[i1:i2])
      b_out.append(cls.__GREEN if tag == "replace" or tag == "insert" else cls.__DEFAULT)
      b_out.append(b[j1:j2])

    a_out.append(cls.__DEFAULT)
    b_out.append(cls.__DEFAULT)

    if len(a) > 0:
      print("".join(a_out))
    if len(b) > 0:
      print("".join(b_out))
    print()


class Tag:
  __tag_re = re.compile(r"""
    (
      (?P<prefix> [@+] )  # project/context prefix
      (?P<name> \S+ )     # name
    |
      (?P<key> \S+? ) :   # key:
      (?!//)              # don't match URLs
      (?P<value> \S+ )    # value
    )
  """, re.VERBOSE)

  @staticmethod
  def __handle_match(m):
    raw = m.group(0)
    prefix = m.group("prefix")
    name = m.group("name")
    key = m.group("key")
    value = m.group("value")
    if prefix:
      assert name, "name should be captured if prefix is captured: %s" % raw
      if prefix == "@":
        tag = ContextTag(name)
      elif prefix == "+":
        tag = ProjectTag(name)
      else:
        assert False, "unknown prefix: %s" % prefix
    else:
      assert key and value, "key and value should be captured if prefix is not: %s" % raw
      tag = KeyValueTag(key, value)
    assert tag.raw == raw, "parsing should not lose information: <%s>" % raw
    return tag

  @classmethod
  def parse(cls, raw):
    m = cls.__tag_re.match(raw)
    if m and m.group(0) == raw: # check the whole string was matched
      return cls.__handle_match(m)
    else:
      return None

  # returns a list of Tags and non-empty strings
  @classmethod
  def tokenize(cls, raw):
    tokens = []
    pos = 0

    def handle_str(end):
      str_token = raw[pos:end]
      if len(str_token) > 0:
        tokens.append(str_token)

    for m in cls.__tag_re.finditer(raw):
      handle_str(m.start())
      tokens.append(cls.__handle_match(m))
      pos = m.end()

    handle_str(len(raw))

    return tokens

  def sort_key(self):
    raise NotImplementedError

  def __init__(self, raw):
    self.raw = raw

  def __repr__(self):
    return self.raw

  def __eq__(self, other):
    return other is not None and self.raw.__eq__(other.raw)

  def __ne__(self, other):
    return not self.__eq__(other)

  def __hash__(self):
    return self.raw.__hash__()


class ContextTag(Tag):
  def __init__(self, name):
    self.name = name
    Tag.__init__(self, "@" + name)

  def sort_key(self):
    return (0, self.name, None)


class ProjectTag(Tag):
  def __init__(self, name):
    self.name = name
    Tag.__init__(self, "+" + name)

  def sort_key(self):
    return (1, self.name, None)


class KeyValueTag(Tag):
  def __init__(self, key, value):
    self.key = key
    self.value = value
    Tag.__init__(self, key + ":" + value)

  def sort_key(self):
    return (2, self.key, self.value)


class Task:
  __task_re = re.compile(r"""
    ^
    ( x \s+ (?P<complete> [0-9]{4}-[0-9]{2}-[0-9]{2} ) \s+ )?
    ( \( (?P<priority> [A-Z] ) \) \s+ )?
    ( (?P<create> [0-9]{4}-[0-9]{2}-[0-9]{2} ) \s+ )?
    (?P<title> .*? )
    $
  """, re.VERBOSE)

  @staticmethod
  def __parse_date(date_str):
    if date_str is None:
      return None
    try:
      return datetime.strptime(date_str, '%Y-%m-%d').date()
    except ValueError:
      return None

  @classmethod
  def load_all(cls, path):
    with open(path, "r", encoding="utf-8") as f:
      tasks = {}
      for i, line in enumerate(f):
        id = i + 1
        line1 = line.rstrip("\r\n")
        if len(line1) > 0:
          tasks[id] = cls.parse(line1)
      return tasks

  @classmethod
  def save_all(cls, tasks, path):
    with open(path, "w", encoding="utf-8") as f:
      max_id = max(tasks.keys()) if len(tasks) > 0 else 0
      for id in range(1, max_id + 1):
        if id in tasks:
          task = tasks[id]
          f.write(task.line)
          f.write("\n")
        elif preserve_line_numbers:
          f.write("\n")

  @classmethod
  def sorted(cls, tasks, key = lambda task: task.line):
    return {i + 1: task for i, task in enumerate(sorted(tasks.values(), key = key))}

  @classmethod
  def parse(cls, line):
    m = cls.__task_re.match(line)
    assert m is not None, "__task_re should match all lines: %s" % line
    title = m.group("title")
    priority = m.group("priority")
    create_date = cls.__parse_date(m.group("create"))
    complete_date = cls.__parse_date(m.group("complete"))
    task = cls(title, priority, create_date, complete_date)
    assert task.line == line, "parsing should not lose information: <%s>" % line
    return task

  def __init__(self, title, priority, create_date = date.today(), complete_date = None):
    self.title = title
    self.priority = priority
    self.create_date = create_date
    self.complete_date = complete_date
    self.line = "".join([
      "x %s " % complete_date.isoformat() if complete_date else "",
      "(%s) " % priority if priority else "",
      "%s " % create_date.isoformat() if create_date else "",
      title
    ])
    # the rest is derived data
    self.tokens = Tag.tokenize(title)
    self.tags = { token for token in self.tokens if isinstance(token, Tag) }
    self.start_date = self.get_key_value_date("t")
    self.due_date = self.get_key_value_date("due")

  def __repr__(self):
    return self.line

  def __eq__(self, other):
    return other is not None and self.line.__eq__(other.line)

  def __ne__(self, other):
    return not self.__eq__(other)

  def __hash__(self):
    return self.line.__hash__()

  def is_hidden(self):
    return self.complete_date or (self.start_date and self.start_date > date.today())

  def remove_tags(self, tags):
    title = self.title
    for tag in tags & self.tags:
      title = title.replace(" " + tag.raw, "")
      title = title.replace(tag.raw + " ", "")
      title = title.replace(   tag.raw   , "")
    return Task(title, self.priority, self.create_date, self.complete_date)

  def add_tags(self, tags, prepend = False):
    title = self.title
    for tag in sorted(tags - self.tags, key = lambda tag: tag.sort_key()):
      title = tag.raw + " " + title if prepend else title + " " + tag.raw
    return Task(title, self.priority, self.create_date, self.complete_date)

  def get_key_value_date(self, key):
    tag = self.get_key_value_tag(key)
    return self.__parse_date(tag.value) if tag else None

  def get_key_value_tag(self, key):
    tags = { tag for tag in self.tags if isinstance(tag, KeyValueTag) and tag.key == key }
    if len(tags) == 0:
      return None
    tag = tags.pop()
    if len(tags) > 0:
      log("ignoring duplicate tags: %s" % tags) # TODO: test
    return tag

  def pop_key_value_tag(self, key):
    tags = { tag for tag in self.tags if isinstance(tag, KeyValueTag) and tag.key == key }
    if len(tags) == 0:
      return None, self
    task = self.remove_tags(tags)
    tag = tags.pop()
    if len(tags) > 0:
      log("discarding duplicate tags: %s" % tags) # TODO: test
    return tag, task

  def set_priority(self, priority):
    return Task(self.title, priority, self.create_date, self.complete_date)

  def set_create_date(self, create_date):
    return Task(self.title, self.priority, create_date, self.complete_date)


class TaskFilter:
  def matches(task):
    raise NotImplementedError

  def apply(task):
    raise NotImplementedError

  def unapply(filtered_task):
    raise NotImplementedError


class InboxTaskFilter(TaskFilter):
  def __init__(self):
    pass

  def matches(self, task):
    return not task.priority or (task.start_date and task.start_date <= date.today()) # todo: add more rules

  def apply(self, task):
    filtered_task = task
    filtered_task = filtered_task.set_create_date(None)
    return filtered_task

  def unapply(self, filtered_task, original_task):
    task = filtered_task
    task = task.set_create_date(original_task.create_date if original_task else default_create_date)
    return task


class MatchTaskFilter(TaskFilter):
  def __init__(self, priority = None, tags = set()):
    self.priority = priority
    self.tags = tags

  def matches(self, task):
    return (not self.priority or task.priority == self.priority) and task.tags >= self.tags

  def apply(self, task):
    filtered_task = task
    filtered_task = filtered_task.remove_tags(self.tags)
    filtered_task = filtered_task.set_priority(None if self.priority else task.priority)
    filtered_task = filtered_task.set_create_date(None)
    return filtered_task

  def unapply(self, filtered_task, original_task):
    task = filtered_task
    task = task.set_create_date(original_task.create_date if original_task else default_create_date)
    task = task.set_priority((task.priority or self.priority) if not task.complete_date else None)
    task = task.add_tags(self.tags)
    return task


class ReviewTaskFilter(TaskFilter):
  # unprioritized tasks must be performed on the day they are defined, or they will show up in the next review
  __no_priority_interval = timedelta(days = 1)
  # unconfigured priorities will never escape the review
  __unconfigured_priority_interval = timedelta(days = 0)

  def __init__(self, priority_to_interval):
    self.priority_to_interval = priority_to_interval

  def matches(self, task):
    if not task.create_date:
      return True

    age = date.today() - task.create_date

    if task.priority:
      interval = self.priority_to_interval[task.priority] if task.priority in self.priority_to_interval else self.__unconfigured_priority_interval
    else:
      interval = self.__no_priority_interval

    return age >= interval

  def apply(self, task):
    act_tag = KeyValueTag("act", "_")
    filtered_task = task
    filtered_task = filtered_task.add_tags(set([act_tag]), prepend = True)
    return filtered_task

  def unapply(self, filtered_task, original_task):
    task = filtered_task
    create_date = task.create_date
    priority = task.priority if not task.complete_date else None

    act_tag, task = task.pop_key_value_tag("act")
    if act_tag and not task.is_hidden():
      if act_tag.value == "_":
        pass
      elif act_tag.value == "k":
        create_date = date.today()
        priority = task.priority
      elif act_tag.value == "i":
        if task.priority:
          create_date = date.today()
          priority = chr(max(ord(task.priority) - 1, ord("A"))) #todo: take into account review periods
        else:
          log("task does not have a priority to increase: %s" % task)
      elif act_tag.value == "d":
        if task.priority:
          create_date = date.today()
          priority = chr(min(ord(task.priority) + 1, ord("Z"))) #todo: take into account review periods
        else:
          log("task does not have a priority to decrease: %s" % task)
      else:
        log("discarding unknown command: %s" % act_tag.value)

    task = task.set_priority(priority)
    task = task.set_create_date(create_date)
    return task


class BatchEditor:
  def __init__(self, tasks, task_filter):
    self.tasks = tasks
    self.task_filter = task_filter
    self.max_id = max(tasks.keys()) if len(tasks) > 0 else 0
    self.max_id_len = len(str(self.max_id))
    self.editable_tasks = self.__get_editable_tasks(tasks, task_filter, self.max_id_len)
    self.sorted_editable_tasks = Task.sorted(self.editable_tasks)

  @staticmethod
  def __get_editable_tasks(tasks, task_filter, max_id_len):
    editable_tasks = {}
    for id, task in tasks.items():
      if (not task.is_hidden() or disable_filter) and task_filter.matches(task):
        id_tag = KeyValueTag("i", str(id).zfill(max_id_len))
        editable_task = task_filter.apply(task)
        editable_task = editable_task.add_tags(set([id_tag]), prepend = True)
        editable_tasks[id] = editable_task
    return editable_tasks

  def __recover_task_ids(self, edited_tasks):
    recovered_edited_tasks = {}
    next_id = len(self.tasks) + 1
    for task in edited_tasks.values():
      id = None
      id_tag, task = task.pop_key_value_tag("i")
      if id_tag:
        tmpid = int(id_tag.value)
        if tmpid in self.editable_tasks: # safety check
          id = tmpid
        else:
          log("ignoring invalid id: %s" % id_tag) #todo: test
      if id is None:
        id = next_id
        next_id += 1
      recovered_edited_tasks[id] = task
    return recovered_edited_tasks

  def __diff(self, id, task_a, task_b):
    header = "%s " % str(id).zfill(self.max_id_len)
    log_a = task_a.line if task_a else ""
    log_b = task_b.line if task_b else ""
    ColorDiff.diff(header, log_a, log_b)

  def __merge_edited_tasks(self, edited_tasks):
    recovered_edited_tasks = self.__recover_task_ids(edited_tasks)
    merged_tasks = self.tasks.copy()

    for id in self.editable_tasks.keys() - recovered_edited_tasks.keys():
      existing_task = merged_tasks[id]
      self.__diff(id, existing_task, None)
      del merged_tasks[id]

    for id, edited_task in recovered_edited_tasks.items():
      existing_task = merged_tasks[id] if id in merged_tasks else None

      task = self.task_filter.unapply(edited_task, existing_task)

      if existing_task != task:
        self.__diff(id, existing_task, task)
        merged_tasks[id] = task

    return merged_tasks

  @staticmethod
  def __edit(tasks):
    # we want the file to be named todo.txt for compatibility with syntax-highlighting editors
    with tempfile.TemporaryDirectory() as temp_dir_path:
      temp_todo_path = os.path.join(temp_dir_path, "todo.txt")
      Task.save_all(tasks, temp_todo_path)
      subprocess.check_call([editor_path, temp_todo_path])
      return Task.load_all(temp_todo_path)

  def edit_and_merge(self):
    edited_tasks = self.__edit(self.sorted_editable_tasks)
    merged_tasks = self.__merge_edited_tasks(edited_tasks)
    return merged_tasks


def usage():
  # TODO: detect script name
  print("  slice <command> [<args>]")
  print("    Opens a 'slice' of your tasks in $EDITOR.")
  print("    The slice is itself a valid todo file, so editor plugins will continue to work.")
  print("    The slice is automatically sorted, and completed/future tasks are filtered.")
  print("    After editing, changes to the slice will be merged back into todo.txt,")
  print("    and a colorized diff will be printed to the console.")
  print()
  print("    Note: The -t, -n and -x options of todo.sh are supported.")
  print("          These should be placed before 'slice'.")
  print()
  print("    inbox")
  print("      Opens 'inbox' tasks. Your 'inbox' includes:")
  print("      - tasks without priorities")
  print("      - tasks with a start date (t:<date>) that has expired (today or in the past)")
  print()
  print("    match [PRIORITY] [TAG...]")
  print("      Opens tasks matching PRIORITY and/or TAG(s).")
  print("      PRIORITY and TAG(s) will be automatically applied to all edited tasks.")
  print()
  print("      PRIORITY (if supplied) must be a single uppercase letter.")
  print()
  print("      TAG(s) can be @contexts, +projects or custom key:value extensions.")
  print()
  print("      If neither PRIORITY nor TAG(s) are supplied, all tasks will be matched.")
  print()
  print("    review")
  print("      Opens tasks for review after they have reached a certain age.")
  print()
  print("      The review age for each priority is defined in TODOTXT_SLICE_REVIEW_INTERVALS,")
  print("      which should consist of <priority>:<interval> pairs separated by commas.")
  print()
  print("      For example, 'A:1,B:7,C:56,Z:182' means:")
  print("      - 'A' tasks should be reviewed after 1 day")
  print("      - 'B' tasks should be reviewed after 7 days")
  print("      - 'C' tasks should be reviewed after 56 days")
  print("      - 'Z' tasks should be reviewed after 182 days")
  print()
  print("      By default, tasks with no priority will require review after a single day,")
  print("      and tasks with unconfigured priorities will _never_ escape review.")
  print()


def build_inbox_filter(args, env):
  return InboxTaskFilter()


def build_match_filter(args, env):
  priority = None
  tags = set()

  if len(args) > 0 and len(args[0]) == 1:
    priority = args.pop(0)
    if priority not in string.ascii_uppercase:
      usage()
      sys.exit(1)

  while len(args) > 0:
    arg = args.pop()
    tag = Tag.parse(arg)
    if not tag:
      usage()
      sys.exit(1)
    tags.add(tag)

  return MatchTaskFilter(priority, tags)


def build_review_filter(args, env):
  key = "TODOTXT_SLICE_REVIEW_INTERVALS"
  if key not in env:
    log("Environment variable %s is not defined" % key)
    log()
    usage()
    sys.exit(1)

  value = env[key]
  priority_to_interval = {}

  for priority_interval_str in value.split(","):
    pair = priority_interval_str.split(":")
    if len(pair) != 2:
      log("Error parsing %s='%s': expected <priority>:<interval> pairs separated by commas" % (key, value))
      log()
      usage()
      sys.exit(1)

    [priority, interval_str] = pair

    if priority not in string.ascii_uppercase:
      log("Error parsing %s='%s': %s is not a priority" % (key, value, priority))
      log()
      usage()
      sys.exit(1)

    try:
      interval = int(interval_str)
    except ValueError:
      log("Error parsing %s='%s': %s is not an integer" % (key, value, interval_str))
      log()
      usage()
      sys.exit(1)

    priority_to_interval[priority] = timedelta(days = interval)

  return ReviewTaskFilter(priority_to_interval)


def build_filter(name, args, env):
  filters = {
    "inbox": build_inbox_filter,
    "match": build_match_filter,
    "review": build_review_filter
  }

  if name not in filters:
    usage()
    sys.exit(1)

  return filters[name](args, env)


def main(args, env):
  if len(args) < 2:
    usage()
    sys.exit(1)

  action_name = args[1]
  action_args = args[2:]

  if action_name == "usage":
    usage()
    sys.exit(0)

  if len(action_args) < 1:
    usage()
    sys.exit(1)

  filter_name = action_args[0]
  filter_args = action_args[1:]

  tasks = Task.load_all(todo_file_path)

  task_filter = build_filter(filter_name, filter_args, env)
  editor = BatchEditor(tasks, task_filter)
  merged_tasks = editor.edit_and_merge()

  Task.save_all(merged_tasks, todo_file_path)


if __name__ == "__main__":
  main(sys.argv, os.environ)


#!/usr/bin/env python3
from datetime import date, datetime, timedelta
import difflib
import os
import re
import string
import subprocess
import sys
import tempfile

def log(str=""):
  sys.stderr.write(str)
  sys.stderr.write("\n")


class ColorDiff:
  __CYAN = "\033[36m"
  __RED = "\033[31m"
  __GREEN = "\033[32m"
  __DEFAULT = "\033[0m"

  # prints colored diff lines to the terminal
  @classmethod
  def diff(cls, header, a, b):
    a_out = [cls.__CYAN, header]
    b_out = [cls.__CYAN, header]

    sm = difflib.SequenceMatcher(a = a, b = b, autojunk = False)
    for tag, i1, i2, j1, j2 in sm.get_opcodes():
      a_out.append(cls.__RED if tag == "replace" or tag == "delete" else cls.__DEFAULT)
      a_out.append(a[i1:i2])
      b_out.append(cls.__GREEN if tag == "replace" or tag == "insert" else cls.__DEFAULT)
      b_out.append(b[j1:j2])

    a_out.append(cls.__DEFAULT)
    b_out.append(cls.__DEFAULT)

    if len(a) > 0:
      print("".join(a_out))
    if len(b) > 0:
      print("".join(b_out))
    print()


class TodoEnv:
  today = date.today()

  def __init__(self):
    self.todo_dir_path = os.environ["TODO_DIR"]
    self.todo_file_path = os.environ["TODO_FILE"]
    self.editor_path = os.environ["EDITOR"]
    self.date_on_add = os.environ["TODOTXT_DATE_ON_ADD"] == "1"
    self.default_create_date = self.today if self.date_on_add else None
    self.preserve_line_numbers = os.environ["TODOTXT_PRESERVE_LINE_NUMBERS"] == "1"
    self.disable_filter = os.environ["TODOTXT_DISABLE_FILTER"] == "1"
    self.slice_review_intervals = os.environ["TODOTXT_SLICE_REVIEW_INTERVALS"]

  def read_lines(self, path):
    with open(path, "r", encoding="utf-8") as f:
      return f.read().splitlines()

  def write_lines(self, path, lines):
    with open(path, "w", encoding="utf-8") as f:
      for line in lines:
        f.write(line)
        f.write("\n")

  def create_temp_dir(self):
    return tempfile.TemporaryDirectory()

  def launch_editor(self, path):
    subprocess.check_call([self.editor_path, path])


class Priority:
  __priority_re = re.compile(r"""^
    ( \( (?P<level> [A-Z_] ) \) )?
  $""", re.VERBOSE)

  @classmethod
  def parse(cls, raw):
    m = cls.__priority_re.match(raw)
    if m is None:
      raise ValueError("Cannot parse priority: %s" % raw)
    raw_level = m.group("level")
    explicit = raw_level is not None
    level = raw_level if raw_level != "_" else None
    priority = Priority(level, explicit)
    assert priority.raw == raw, "parsing should not lose information: <%s> != <%s>" % (priority.raw, raw)
    return priority

  def __init__(self, level, explicit_no_level = False):
    if level is not None and level not in string.ascii_uppercase:
      raise ValueError("Invalid level: %s" % level)
    self.level = level
    self.explicit = level is not None or explicit_no_level
    self.raw = "(" + (level or "_") + ")" if self.explicit else ""

  def normalize(self, explicit_no_level):
    return Priority(self.level, explicit_no_level) if not self.level and self.explicit != explicit_no_level else self

  def __repr__(self):
    return self.raw

  # ignore explicitness in comparison
  def __eq__(self, other):
    return other is not None and self.level.__eq__(other.level)

  def __ne__(self, other):
    return not self.__eq__(other)

  def __hash__(self):
    return self.level.__hash__()


class Tag:
  __tag_re = re.compile(r"""
    (
      (?P<prefix> [@+] )  # project/context prefix
      (?P<name> \S+ )     # name
    |
      (?P<key> \S+? ) :   # key:
      (?!//)              # don't match URLs
      (?P<value> \S+ )    # value
    )
  """, re.VERBOSE)

  @staticmethod
  def __handle_match(m):
    raw = m.group(0)
    prefix = m.group("prefix")
    name = m.group("name")
    key = m.group("key")
    value = m.group("value")
    if prefix:
      assert name, "name should be captured if prefix is captured: %s" % raw
      if prefix == "@":
        tag = ContextTag(name)
      elif prefix == "+":
        tag = ProjectTag(name)
      else:
        assert False, "unknown prefix: %s" % prefix
    else:
      assert key and value, "key and value should be captured if prefix is not: %s" % raw
      tag = KeyValueTag(key, value)
    assert tag.raw == raw, "parsing should not lose information: <%> != <%s>" % (tag.raw, raw)
    return tag

  @classmethod
  def parse(cls, raw):
    m = cls.__tag_re.match(raw)
    if m and m.group(0) == raw: # check the whole string was matched
      return cls.__handle_match(m)
    else:
      raise ValueError("Cannot parse tag: %s" % raw)

  # returns a list of Tags and non-empty strings
  @classmethod
  def tokenize(cls, raw):
    tokens = []
    pos = 0

    def handle_str(end):
      str_token = raw[pos:end]
      if len(str_token) > 0:
        tokens.append(str_token)

    for m in cls.__tag_re.finditer(raw):
      handle_str(m.start())
      tokens.append(cls.__handle_match(m))
      pos = m.end()

    handle_str(len(raw))

    return tokens

  def sort_key(self):
    raise NotImplementedError

  def __init__(self, raw):
    self.raw = raw

  def __repr__(self):
    return self.raw

  def __eq__(self, other):
    return other is not None and self.raw.__eq__(other.raw)

  def __ne__(self, other):
    return not self.__eq__(other)

  def __hash__(self):
    return self.raw.__hash__()


class ContextTag(Tag):
  def __init__(self, name):
    self.name = name
    Tag.__init__(self, "@" + name)

  def sort_key(self):
    return (0, self.name, None)


class ProjectTag(Tag):
  def __init__(self, name):
    self.name = name
    Tag.__init__(self, "+" + name)

  def sort_key(self):
    return (1, self.name, None)


class KeyValueTag(Tag):
  def __init__(self, key, value):
    self.key = key
    self.value = value
    Tag.__init__(self, key + ":" + value)

  def sort_key(self):
    return (2, self.key, self.value)


class Task:
  __task_re = re.compile(r"""
    ^
    ( x \s+ (?P<complete> [0-9]{4}-[0-9]{2}-[0-9]{2} ) \s+ )?
    ( (?P<priority> \( [A-Z_] \) ) \s+ )?
    ( (?P<create> [0-9]{4}-[0-9]{2}-[0-9]{2} ) \s+ )?
    (?P<title> .*? )
    $
  """, re.VERBOSE)

  @staticmethod
  def __parse_date(date_str):
    if date_str is None:
      return None
    try:
      return datetime.strptime(date_str, '%Y-%m-%d').date()
    except ValueError:
      return None

  @classmethod
  def load_all(cls, env, path):
    tasks = {}
    for i, line in enumerate(env.read_lines(path)):
      id = i + 1
      line1 = line.rstrip("\r\n")
      if len(line1) > 0:
        tasks[id] = cls.parse(line1)
    return tasks

  @classmethod
  def save_all(cls, env, tasks, path):
    lines = []
    max_id = max(tasks.keys()) if len(tasks) > 0 else 0
    for id in range(1, max_id + 1):
      if id in tasks:
        task = tasks[id]
        lines.append(task.line)
      elif env.preserve_line_numbers:
        lines.append("")
    env.write_lines(path, lines)

  @classmethod
  def sorted(cls, tasks, key = lambda task: task.line):
    return {i + 1: task for i, task in enumerate(sorted(tasks.values(), key = key))}

  @classmethod
  def parse(cls, line):
    m = cls.__task_re.match(line)
    assert m is not None, "__task_re should match all lines: %s" % line
    title = m.group("title")
    priority = Priority.parse(m.group("priority")) if m.group("priority") else Priority(None)
    create_date = cls.__parse_date(m.group("create"))
    complete_date = cls.__parse_date(m.group("complete"))
    task = cls(title, priority, create_date, complete_date)
    def remove_whitespace(s):
      "".join(s.split())
    assert remove_whitespace(task.line) == remove_whitespace(line), "parsing should not lose information other than whitespace: <%s> != <%s>" % (task.line, line)
    return task

  def __init__(self, title, priority, create_date, complete_date):
    self.title = title
    self.priority = priority
    self.create_date = create_date
    self.complete_date = complete_date
    self.line = "".join([
      "x %s " % complete_date.isoformat() if complete_date else "",
      priority.raw + (" " if len(priority.raw) > 0 else ""),
      "%s " % create_date.isoformat() if create_date else "",
      title
    ])
    # the rest is derived data
    self.tokens = Tag.tokenize(title)
    self.tags = { token for token in self.tokens if isinstance(token, Tag) }
    self.start_date = self.get_key_value_date("t")
    self.due_date = self.get_key_value_date("due")

  def __repr__(self):
    return self.line

  def __eq__(self, other):
    return other is not None and self.line.__eq__(other.line)

  def __ne__(self, other):
    return not self.__eq__(other)

  def __hash__(self):
    return self.line.__hash__()

  def is_hidden(self, date):
    return self.complete_date or (self.start_date and self.start_date > date)

  def remove_tags(self, tags):
    title = self.title
    for tag in tags & self.tags:
      title = title.replace(" " + tag.raw, "")
      title = title.replace(tag.raw + " ", "")
      title = title.replace(   tag.raw   , "")
    return Task(title, self.priority, self.create_date, self.complete_date)

  # canonicalizes the order of tags at the edge of the title so that different slices make idempotent edits
  def add_tags(self, tags, prepend = False):
    # the "edge" is the start if prepend is true, else the end
    # split tokens into "tags at the edge", and whatever remains
    edge_tags = set()
    edge_pos = 0 if prepend else -1
    rem_tokens = self.tokens[:]
    while len(rem_tokens) > 0:
      token = rem_tokens[edge_pos]
      if isinstance(token, Tag):
        edge_tags.add(token)
      else:
        assert isinstance(token, str) and len(token) > 0, "Expected non-Tag token to be a non-empty string: %s" % token
        if not token.isspace():
          # no longer at edge
          break
      rem_tokens.pop(edge_pos)

    # join the remaining tokens, then _sort_ and add edge tokens
    title = "".join([str(token) for token in rem_tokens]).strip()
    edge = " ".join([str(tag) for tag in sorted(edge_tags | (tags - self.tags), key = lambda tag: tag.sort_key())])
    if len(edge) > 0:
      title = edge + " " + title if prepend else title + " " + edge
    return Task(title, self.priority, self.create_date, self.complete_date)

  def get_key_value_date(self, key):
    tag = self.get_key_value_tag(key)
    return self.__parse_date(tag.value) if tag else None

  def get_key_value_tag(self, key):
    tags = { tag for tag in self.tags if isinstance(tag, KeyValueTag) and tag.key == key }
    if len(tags) == 0:
      return None
    tag = tags.pop()
    if len(tags) > 0:
      log("ignoring duplicate tags: %s" % tags) # TODO: test
    return tag

  def pop_key_value_tag(self, key):
    tags = { tag for tag in self.tags if isinstance(tag, KeyValueTag) and tag.key == key }
    if len(tags) == 0:
      return None, self
    task = self.remove_tags(tags)
    tag = tags.pop()
    if len(tags) > 0:
      log("discarding duplicate tags: %s" % tags) # TODO: test
    return tag, task

  def set_priority(self, priority):
    return Task(self.title, priority, self.create_date, self.complete_date)

  def set_create_date(self, create_date):
    return Task(self.title, self.priority, create_date, self.complete_date)


class TaskFilter:
  def __init__(self, env):
    self.env = env

  def matches(task):
    raise NotImplementedError

  def apply(task):
    raise NotImplementedError

  def unapply(filtered_task):
    raise NotImplementedError


class InboxTaskFilter(TaskFilter):
  def __init__(self, env):
    TaskFilter.__init__(self, env)

  def matches(self, task):
    return not task.priority.level or (task.start_date and task.start_date <= self.env.today) # todo: add more rules

  def apply(self, task):
    filtered_task = task
    filtered_task = filtered_task.set_create_date(None)
    return filtered_task

  def unapply(self, filtered_task, original_task):
    task = filtered_task
    task = task.set_create_date(original_task.create_date if original_task else self.env.default_create_date)
    return task


class MatchTaskFilter(TaskFilter):
  def __init__(self, env, priority = None, tags = set()):
    TaskFilter.__init__(self, env)
    self.priority = priority
    self.tags = tags

  def matches(self, task):
    return (not self.priority or task.priority == self.priority) and task.tags >= self.tags

  def apply(self, task):
    filtered_task = task
    filtered_task = filtered_task.remove_tags(self.tags)
    filtered_task = filtered_task.set_priority(Priority(None) if self.priority else task.priority)
    filtered_task = filtered_task.set_create_date(None)
    return filtered_task

  def unapply(self, filtered_task, original_task):
    task = filtered_task
    task = task.set_create_date(original_task.create_date if original_task else self.env.default_create_date)
    if self.priority and not task.priority.level:
      task = task.set_priority(self.priority)
    task = task.add_tags(self.tags)
    return task


class ReviewTaskFilter(TaskFilter):
  def __init__(self, env, priority_to_interval):
    TaskFilter.__init__(self, env)
    self.priority_to_interval = priority_to_interval

  def matches(self, task):
    if not task.create_date:
      return True

    age = self.env.today - task.create_date
    interval = self.priority_to_interval[task.priority]
    return age >= interval

  def apply(self, task):
    filtered_task = task
    filtered_task = filtered_task.set_priority(Priority(None, True))
    filtered_task = filtered_task.set_create_date(None)
    return filtered_task

  def unapply(self, filtered_task, original_task):
    task = filtered_task

    if task.priority.level or task.is_hidden(self.env.today):
      # successful review; reset create_date to today if it's not completed already
      task = task.set_create_date(self.env.today if not task.complete_date else original_task.create_date)
      task = task.set_priority(task.priority if task.priority.level else original_task.priority)
    else:
      # failed review; restore create_date and priority
      task = task.set_create_date(original_task.create_date if original_task else self.env.default_create_date)
      task = task.set_priority(original_task.priority if original_task else Priority(None))

    return task


class BatchEditor:
  def __init__(self, env, tasks, task_filter):
    self.env = env
    self.tasks = tasks
    self.task_filter = task_filter
    self.max_id = max(tasks.keys()) if len(tasks) > 0 else 0
    self.max_id_len = len(str(self.max_id))
    self.editable_tasks = self.__get_editable_tasks(tasks, task_filter, self.max_id_len)
    self.sorted_editable_tasks = Task.sorted(self.editable_tasks)

  def __get_editable_tasks(self, tasks, task_filter, max_id_len):
    editable_tasks = {}
    for id, task in tasks.items():
      if (not task.is_hidden(self.env.today) or self.env.disable_filter) and task_filter.matches(task):
        id_tag = KeyValueTag("i", str(id).zfill(max_id_len))
        editable_task = task_filter.apply(task)
        editable_task = editable_task.add_tags(set([id_tag]), prepend = True)
        editable_tasks[id] = editable_task
    return editable_tasks

  def __recover_task_ids(self, edited_tasks):
    recovered_edited_tasks = {}
    next_id = self.max_id + 1
    for task in edited_tasks.values():
      id = None
      id_tag, task = task.pop_key_value_tag("i")
      if id_tag:
        try:
          tmpid = int(id_tag.value)
          if tmpid in self.editable_tasks: # safety check
            id = tmpid
          else:
            log("ignoring unknown id: %s" % id_tag)
        except ValueError:
          log("ignoring invalid id: %s" % id_tag)
      if id is None:
        id = next_id
        next_id += 1
      recovered_edited_tasks[id] = task
    return recovered_edited_tasks

  def __diff(self, id, task_a, task_b):
    header = "%s " % str(id).zfill(self.max_id_len)
    log_a = task_a.line if task_a else ""
    log_b = task_b.line if task_b else ""
    ColorDiff.diff(header, log_a, log_b)

  def __merge_edited_tasks(self, edited_tasks):
    recovered_edited_tasks = self.__recover_task_ids(edited_tasks)
    merged_tasks = self.tasks.copy()

    for id in self.editable_tasks.keys() - recovered_edited_tasks.keys():
      existing_task = merged_tasks[id]
      self.__diff(id, existing_task, None)
      del merged_tasks[id]

    for id, edited_task in recovered_edited_tasks.items():
      existing_task = merged_tasks[id] if id in merged_tasks else None

      task = self.task_filter.unapply(edited_task, existing_task)

      priority = task.priority if not task.complete_date else Priority(None)
      task = task.set_priority(priority.normalize(explicit_no_level = False))

      task = task

      if existing_task != task:
        self.__diff(id, existing_task, task)
        merged_tasks[id] = task

    return merged_tasks

  def __edit(self, tasks):
    # we want the file to be named todo.txt for compatibility with syntax-highlighting editors
    with self.env.create_temp_dir() as temp_dir_path:
      temp_todo_path = os.path.join(temp_dir_path, "todo.txt")
      Task.save_all(self.env, tasks, temp_todo_path)
      self.env.launch_editor(temp_todo_path)
      return Task.load_all(self.env, temp_todo_path)

  def edit_and_merge(self):
    edited_tasks = self.__edit(self.sorted_editable_tasks)
    merged_tasks = self.__merge_edited_tasks(edited_tasks)
    return merged_tasks


def usage():
  # TODO: detect script name
  print("  slice <command> [<args>]")
  print("    Opens a 'slice' of your tasks in $EDITOR.")
  print("    The slice is itself a valid todo file, so editor plugins will continue to work.")
  print("    The slice is automatically sorted, and completed/future tasks are filtered.")
  print("    After editing, changes to the slice will be merged back into todo.txt,")
  print("    and a colorized diff will be printed to the console.")
  print()
  print("    Note: The -t, -n and -x options of todo.sh are supported.")
  print("          These should be placed before 'slice'.")
  print()
  print("    inbox")
  print("      Opens 'inbox' tasks. Your 'inbox' includes:")
  print("      - tasks without priorities")
  print("      - tasks with a start date (t:<date>) that has expired (today or in the past)")
  print()
  print("    match [PRIORITY] [TAG...]")
  print("      Opens tasks matching PRIORITY and/or TAG(s).")
  print("      PRIORITY and TAG(s) will be automatically applied to all edited tasks.")
  print()
  print("      PRIORITY (if supplied) must be a single uppercase letter.")
  print()
  print("      TAG(s) can be @contexts, +projects or custom key:value extensions.")
  print()
  print("      If neither PRIORITY nor TAG(s) are supplied, all tasks will be matched.")
  print()
  print("    review")
  print("      Opens tasks for review after they have reached a certain age.")
  print()
  print("      The review age for each priority is defined in TODOTXT_SLICE_REVIEW_INTERVALS,")
  print("      which should consist of <priority>:<interval> pairs separated by commas.")
  print()
  print("      For example, 'A:1,B:7,C:56,Z:182' means:")
  print("      - 'A' tasks should be reviewed after 1 day")
  print("      - 'B' tasks should be reviewed after 7 days")
  print("      - 'C' tasks should be reviewed after 56 days")
  print("      - 'Z' tasks should be reviewed after 182 days")
  print()
  print("      By default, tasks with no priority will require review after a single day,")
  print("      and tasks with unconfigured priorities will _never_ escape review.")
  print()


def build_inbox_filter(env, args):
  return InboxTaskFilter(env)


def build_match_filter(env, args):
  priority = None
  tags = set()

  if len(args) > 0 and len(args[0]) == 1:
    priority_level = args.pop(0)
    if priority_level != "_" and priority_level not in string.ascii_uppercase: #TODO: this level logic shouldn't be here
      usage()
      sys.exit(1)
    priority = Priority(priority_level if priority_level != "_" else None)

  while len(args) > 0:
    arg = args.pop()
    tag = Tag.parse(arg)
    if not tag:
      usage()
      sys.exit(1)
    tags.add(tag)

  return MatchTaskFilter(env, priority, tags)


def build_review_filter(env, args):
  priority_to_interval = {}

  priority_interval_strs = env.slice_review_intervals.split(",") if len(env.slice_review_intervals) > 0 else []
  for priority_interval_str in priority_interval_strs:
    pair = priority_interval_str.split(":")
    if len(pair) != 2:
      log("Error parsing %s='%s': expected <priority>:<interval> pairs separated by commas" % (key, value))
      log()
      usage()
      sys.exit(1)

    [priority_level, interval_str] = pair

    if priority_level not in string.ascii_uppercase:
      log("Error parsing %s='%s': %s is not a priority" % (key, value, priority))
      log()
      usage()
      sys.exit(1)

    priority = Priority(priority_level)

    try:
      interval = int(interval_str)
    except ValueError:
      log("Error parsing %s='%s': %s is not an integer" % (key, value, interval_str))
      log()
      usage()
      sys.exit(1)

    priority_to_interval[priority] = timedelta(days = interval)

  # unprioritized tasks must be performed on the day they are defined, or they will show up in the next review
  priority_to_interval[Priority(None)] = timedelta(days = 1)

  # unconfigured priorities will never escape the review
  for priority_level in string.ascii_uppercase:
    priority = Priority(priority_level)

    if priority not in priority_to_interval:
      priority_to_interval[priority] = timedelta(days = 0)

  return ReviewTaskFilter(env, priority_to_interval)


def build_filter(env, name, args):
  filters = {
    "inbox": build_inbox_filter,
    "match": build_match_filter,
    "review": build_review_filter
  }

  if name not in filters:
    usage()
    sys.exit(1)

  return filters[name](env, args)


def main(env, args):
  if len(args) < 2:
    usage()
    sys.exit(1)

  action_name = args[1]
  action_args = args[2:]

  if action_name == "usage":
    usage()
    sys.exit(0)

  if len(action_args) < 1:
    usage()
    sys.exit(1)

  filter_name = action_args[0]
  filter_args = action_args[1:]

  tasks = Task.load_all(env, env.todo_file_path)

  task_filter = build_filter(env, filter_name, filter_args)
  editor = BatchEditor(env, tasks, task_filter)
  merged_tasks = editor.edit_and_merge()

  if merged_tasks != tasks:
    Task.save_all(env, merged_tasks, env.todo_file_path)


if __name__ == "__main__":
  main(TodoEnv(), sys.argv)

